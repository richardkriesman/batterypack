import { Buffer } from "buffer";
import * as YAML from "js-yaml";

import { Config } from "../config";
import { PathResolver } from "../../path";
import { Derivation } from "./abstract";
import { when } from "../../helpers";
import { PersistenceFile } from "../file";
import { Credentials } from "../credentials";

/**
 * Builds the configuration for Yarn.
 */
export class YarnDerivation implements Derivation {
  filePath = ".yarnrc.yml";
  toolId = "yarn";

  public async makeDerivation(
    config: PersistenceFile<Config>,
    credentials: PersistenceFile<Credentials>,
    resolver: PathResolver
  ): Promise<Buffer> {
    let contents: string = `#
# STOP! This file is automatically generated.
#
# To add your own configuration options to .yarnrc.yml,
# add them to rocket.yml, then run "rocket sync".
#
`;
    contents += YAML.dump({
      yarnPath: ".yarn/releases/yarn-berry.cjs",
      nodeLinker: config.yarn.linker,
      ...when(config.scopes, (target) => {
        return {
          npmScopes: Object.keys(target).reduce((out, key) => {
            out[key] = {
              npmRegistryServer: target[key].origin,
              npmPublishRegistry: target[key].origin,
            };
            if (target[key].credential !== undefined) {
              if (!credentials.credentials[target[key].credential!]) {
                throw new Error(
                  `No credential named ${target[key].credential} exists in ` +
                    "credentials.yml."
                );
              }
              out[key] = {
                ...out[key],
                npmAlwaysAuth: true,
                npmAuthToken:
                  credentials.credentials[target[key].credential!].profile, // TODO: Dynamically resolve this
              };
            }
            return out;
          }, {} as any),
        };
      }),
    });
    return Buffer.from(contents, "utf-8");
  }
}
