import { Buffer } from "buffer";
import * as YAML from "js-yaml";

import { Derivation } from "./abstract";
import { whenAsync } from "../../when";
import { Project } from "../../project";

/**
 * Builds the configuration for Yarn.
 */
export class YarnDerivation implements Derivation {
  filePath = ".yarnrc.yml";
  toolId = "yarn";

  public async makeDerivation(project: Project): Promise<Buffer> {
    let contents: string = `#
# STOP! This file is automatically generated.
#
# To add your own configuration options to .yarnrc.yml,
# add them to batterypack.yml, then run "batterypack sync".
#
`;
    contents += YAML.dump({
      yarnPath: ".yarn/releases/yarn-berry.cjs",
      nodeLinker: "node-modules", // batterypack doesn't support PnP at the moment
      plugins: [
        {
          path: ".yarn/plugins/@yarnpkg/plugin-compat.cjs",
          spec: "@yarnpkg/plugin-compat",
        },
      ],

      // registry scopes
      ...(await whenAsync(project.config.scopes, async (target) => {
        const scopes: any = {};
        for (const key of Object.keys(target)) {
          const registry = target[key];
          scopes[key] = {
            npmRegistryServer: registry.origin,
            npmPublishRegistry: registry.origin,
          };
          if (target[key].credential !== undefined) {
            if (!project.credentials.credentials[registry.credential!]) {
              throw new Error(
                `No credential named ${registry.credential} exists in ` +
                  "credentials.yml."
              );
            }
            scopes[key] = {
              ...scopes[key],
              npmAlwaysAuth: true,
              npmAuthToken: await project.credentials.fetchNpmAuthToken(
                project.credentials.credentials[registry.credential!]
              ),
            };
          }
        }
        return {
          npmScopes: scopes,
        };
      })),
    });
    return Buffer.from(contents, "utf-8");
  }
}
