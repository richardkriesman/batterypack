import { Buffer } from "buffer";
import * as Path from "path";
import * as YAML from "js-yaml";

import { Derivation } from "@project/derivation/abstract";
import { whenAsync } from "@project/when";
import { Project } from "@project/project";
import { Directory, File } from "@project/io";
import { ProjectPaths } from "@project/paths";

const YARN_RELEASES_DIR: string = ".yarn/releases";
const YARN_RELEASE_DEFAULT: string = "yarn-berry.cjs";

/**
 * Builds the configuration for Yarn.
 */
export class YarnDerivation implements Derivation {
  filePath = ".yarnrc.yml";
  toolId = "yarn";

  public async makeDerivation(project: Project): Promise<Buffer> {
    const yarnRcFile = new File(
      Path.join(
        await project.resolver.resolve(ProjectPaths.root),
        this.filePath
      )
    );
    const yarnReleasesDir = new Directory(YARN_RELEASES_DIR);

    // load existing .yarnrc if it exists - there are values to copy from it
    let yarnRc: { [key: string]: unknown } | undefined;
    if (await yarnRcFile.doesExist()) {
      const fileRaw = YAML.load((await yarnRcFile.readAll()).toString("utf-8"));
      if (typeof fileRaw === "object" && fileRaw !== null) {
        yarnRc = fileRaw as { [key: string]: unknown };
      }
    }

    // autodetect yarn release
    let yarnPath: string | undefined;
    if (
      yarnRc !== undefined &&
      yarnRc.hasOwnProperty("yarnPath") &&
      typeof yarnRc.yarnPath === "string" &&
      (await new File(yarnRc.yarnPath).doesExist())
    ) {
      // .yarnrc exists and the specified release exists, use that
      yarnPath = yarnRc.yarnPath;
    } else if (await yarnReleasesDir.doesExist()) {
      // .yarn/releases exists, check if there's a file in there
      for await (const item of yarnReleasesDir.listContents()) {
        if (item instanceof File) {
          yarnPath = item.path;
          break;
        }
      }
      if (yarnPath === undefined) {
        yarnPath = YARN_RELEASE_DEFAULT;
      }
    } else {
      // can't detect current version, fall back to default
      yarnPath = YARN_RELEASE_DEFAULT;
    }

    let contents: string = `#
# STOP! This file is automatically generated.
#
# To add your own configuration options to .yarnrc.yml,
# add them to batterypack.yml, then run "batterypack sync".
#
`;
    contents += YAML.dump({
      yarnPath: yarnPath,
      nodeLinker: "node-modules", // batterypack doesn't support PnP at the moment
      plugins: [
        {
          path: ".yarn/plugins/@yarnpkg/plugin-compat.cjs",
          spec: "@yarnpkg/plugin-compat",
        },
      ],

      // registry scopes
      ...(await whenAsync(project.config.scopes, async (target) => {
        const scopes: any = {};
        for (const key of Object.keys(target)) {
          const registry = target[key];
          scopes[key] = {
            npmRegistryServer: registry.origin,
            npmPublishRegistry: registry.origin,
          };
          if (target[key].credential !== undefined) {
            if (!project.credentials.credentials[registry.credential!]) {
              throw new Error(
                `No credential named ${registry.credential} exists in ` +
                  "credentials.yml."
              );
            }
            scopes[key] = {
              ...scopes[key],
              npmAlwaysAuth: true,
              npmAuthToken: await project.credentials.fetchNpmAuthToken(
                project.credentials.credentials[registry.credential!]
              ),
            };
          }
        }
        return {
          npmScopes: scopes,
        };
      })),
    });
    return Buffer.from(contents, "utf-8");
  }
}
