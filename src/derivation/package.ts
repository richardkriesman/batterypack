import { Derivation } from "@project/derivation/abstract";
import { Project } from "@project/project";
import { ProjectPaths } from "@project/paths";
import { when } from "@project/when";
import { META } from "@project/meta";
import {
  DependencyRelationship,
  DependencyRelationshipObject,
} from "@project/config";

/**
 * Dependencies to always add to package.json in the format of batterypack.yml
 * dependency declarations.
 */
const DEFAULT_DEPENDENCIES: { [name: string]: DependencyRelationship } = {
  // add batterypack as a dev dependency :>
  batterypack: {
    version: META.version,
    type: "development",
    optional: false,
  },
};

/**
 * Derives package.json.
 */
export class PackageDerivation implements Derivation {
  filePath = "package.json";

  async makeDerivation(project: Project): Promise<Buffer> {
    // build project dependencies
    const dependencyMixin: any = {};
    for (const [name, props] of Object.entries({
      ...(project.config.dependencies ?? {}),
      ...DEFAULT_DEPENDENCIES,
    })) {
      // create an object for props if the shorthand version string was used
      const propsObj: DependencyRelationshipObject =
        typeof props === "string"
          ? {
              version: props,
              type: "private",
              optional: false,
            }
          : props;

      // determine key in package.json
      let key: string;
      switch (propsObj.type) {
        case "development":
          key = "devDependencies";
          break;
        case "peer":
          key = "peerDependencies";
          break;
        case "private":
          if (propsObj.optional) {
            key = "optionalDependencies";
          } else {
            key = "dependencies";
          }
          break;
        default:
          throw new TypeError(
            `Invalid dependency relationship type "${propsObj.type}".`
          );
      }

      // create key if it doesn't exist yet
      if (!dependencyMixin.hasOwnProperty(key)) {
        dependencyMixin[key] = {};
      }

      // add dependency version expression
      dependencyMixin[key][name] = propsObj.version;

      // add optional flag for optional peer dependencies
      if (propsObj.type === "peer" && propsObj.optional) {
        // make the peer dependency optional
        if (!dependencyMixin.hasOwnProperty("peerDependenciesMeta")) {
          dependencyMixin["peerDependenciesMeta"] = {};
        }
        dependencyMixin["peerDependenciesMeta"][name] = {
          optional: true,
        };
      }
    }

    // build file contents
    const contents = {
      _warning:
        "This file is automatically generated by batterypack. " +
        "Changes will be overwritten!",
      name: project.config.name,
      description: project.config.description,
      version: project.config.version ?? "1.0.0",
      license: project.config.license ?? "UNLICENSED",
      main:
        project.config.entrypoint?.build ??
        ProjectPaths.files.defaultBuildEntrypoint.relPath,
      ...when(project.config.author, (target) => ({
        author: {
          name: target.name,
          email: target.email,
        },
      })),
      ...dependencyMixin,
      ...when(
        project.config.overrides,
        (target) => target["package.json"] ?? {}
      ),
    };

    // encode as json
    return Buffer.from(JSON.stringify(contents, null, 2), "utf-8");
  }
}
