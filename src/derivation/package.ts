import { Derivation } from "@project/derivation/abstract";
import { Project } from "@project/project";
import { ProjectPaths } from "@project/paths";
import { when } from "@project/when";
import { META } from "@project/meta";

/**
 * Dependencies to always add to package.json in the format of batterypack.yml
 * dependency declarations.
 */
const DEFAULT_DEPENDENCIES = {
  // add batterypack as a dev dependency :>
  batterypack: {
    version: META.version,
    type: "development",
  },
};

/**
 * Derives package.json.
 */
export class PackageDerivation implements Derivation {
  filePath = "package.json";

  async makeDerivation(project: Project): Promise<Buffer> {
    // build project dependencies
    const dependencyMixin: any = {};
    for (const [name, props] of Object.entries({
      ...(project.config.dependencies ?? {}),
      ...DEFAULT_DEPENDENCIES,
    })) {
      // determine key in package.json
      let key: string;
      switch (props.type) {
        case "development":
          key = "devDependencies";
          break;
        case "shared":
        case "sharedOptional":
          key = "peerDependencies";
          break;
        default:
          key = "dependencies";
      }

      // create key if it doesn't exist yet
      if (!dependencyMixin.hasOwnProperty(key)) {
        dependencyMixin[key] = {};
      }

      // add dependency version expression
      dependencyMixin[key][name] = props.version;
      if (props.type === "sharedOptional") {
        // make the peer dependency optional
        if (!dependencyMixin.hasOwnProperty("peerDependenciesMeta")) {
          dependencyMixin["peerDependenciesMeta"] = {};
        }
        dependencyMixin["peerDependenciesMeta"][name] = {
          optional: true,
        };
      }
    }

    // build file contents
    const contents = {
      _warning:
        "This file is automatically generated by batterypack. " +
        "Changes will be overwritten!",
      name: project.config.name,
      description: project.config.description,
      version: project.config.version ?? "1.0.0",
      license: project.config.license ?? "UNLICENSED",
      main:
        project.config.entrypoint?.build ??
        ProjectPaths.files.defaultBuildEntrypoint.relPath,
      ...when(project.config.author, (target) => ({
        author: {
          name: target.name,
          email: target.email,
        },
      })),
      ...dependencyMixin,
      ...when(
        project.config.overrides,
        (target) => target["package.json"] ?? {}
      ),
    };

    // encode as json
    return Buffer.from(JSON.stringify(contents, null, 2), "utf-8");
  }
}
